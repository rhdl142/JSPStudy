[자바프로그램 다운로드/설치]
자바 다운로드 : java.oracle.com

1. JDK설치(기본설정)
    C:\Program Files\Java\jdk1.8.0_191
    C:\Program Files\Java\jre1.8.0_191

2. 컴퓨터->속성->고급시스템설정-고급 -> 환경변수->시스템변수
    ① 새로만들기
        변수이름 : JAVA_HOME
        변수   값 : C:\Program Files\Java\jdk1.8.0_191
    ② Path 
          %JAVA_HOME%\bin; 

3. cmd창을 띄우고 테스트하기
  $ java -version
  $ javac
     (화면에 도움말이 쭉~~ 올라가면 성공)

4. 도움말(API) 사이트
http://docs.oracle.com/javase/8/docs/api/

5. eclipse 다운로드
www.eclipse.org에서 다운 받기


※ Eclipse 단축키
ctrl + space : 자동완성기능 
ctrl + 1 : import 또는 예외처리 
ctrl + shift + o : 모든 클래스 자동 import 
ctrl + shift + / 또는  \   ==> 주석처리(여러줄)
ctrl + shift + c : 주석처리(한줄)
ctrl + shift + f : 자동정렬
====================================================================
[자바문법]

1. 자바의 분류
   J2SE(Java SE)  : Java2 Standard Edition
   J2EE(Java EE)  : Java2 Enterprise Edition(web관련)
   J2ME(Java ME)  : Java2 Micro Edition(모바일관련)

2. 자바의 특성
①이식성이 높다
②단순하고 견고한 언어
- C++언어와 비슷한 구문사용
- 다중상속, 구조체, 전역변수, 연산자 중복기능등을 제거하여 언어의 복잡성을 제거
- 자동적으로 쓰레기처리
  i)메모리포인터를 사용하지 않는다(내부포인터사용)
  ii)사용되지않는 메모리를 자동으로 회수
- 명시적 선언 및 엄격한 형검사   float a=10.4f;
- 예외처리
③완벽한 객체지향 언어이다
- 프로그램의 재사용, 생산성향상
- 설계 단계부터 객체지향 개념을 고려
④분산환경에 적합한 언어
- TCP/IP 네트워킹 기능을 내장
⑤안전한 언어
- 바이트 코드 검증기를 통해 코드를 검증
- Java애플릿이 클라이언트에서 실행될때 사용할수 없는 
  기능의 리스트가 된다
⑥다중 쓰레드 지원
-다중쓰레드 : 여러개의 작업을 동시에 실행할수 있는 기능
-스레드와 관련된 라이브러리 클래스 제공
⑦동적인 언어
-기존프로그램의 영향을 미치지 않고 라이브러리에 새로운 메소드나 속성을 추가할수 있다

3.JVM (Java Virtual Machine)의 메모리
(1)스택 영역 (Runtime Stack) : 실행시 사용하는 메모리 영역
(2)힙 영역 (Garbage Collection Heap) : 동적 메모리 할당 영역
(3)상수 영역 (Constant & Code Segment) : 상수 데이터 및 static 데이터 할당 영역
(4)레지스터 영역 (Process Register) : 프로세서 실행 관련 메모리 할당 영역

4.자바의 실행 과정
*.java 파일 -> 컴파일(javac) -> *.class 파일 -> 인터프리터(java) -> 실행 결과
 javac 파일명.확장명   <---- 컴파일
$ java 파일명           <---- 실행
----------------------------------------------------------------
5.사용자 정의 명칭 (클래스, Method, Field) - 식별자
(1)첫 글자는 ‘_’, ‘$’, 영문 대,소문자 (한글 가능)
(2)글자수에 제한 없다.
(3)공백문자 및 특수 문자 사용 불가
(4)숫자는 첫 글자가 아닐 때 사용 가능
(5)예약어 사용 불가
(6)기타 단순 약속 (대, 소문자의 규칙)
   int a=10, A=20;   (O)
   int _a=100;          (O)
   int 100a=15;       (X)
   int kor25=100;    (O)
   int k g h = 50;    (X)
   int System=100;  (X)
    

예약어
:자바언어 자체가 사용하기 위해 예약해 놓은 식별자가 있다 
ex)if, for, try, extends.......


ⓐ클래스이름과 파일명은 반드시 동일해야 함
ⓑ컴파일이나 실행할때도 를 구별함 
=============================================
6. 변수/상수
(1)변수
기본데이타형변수 / 참조형변수
(primitive type)      (reference type)

※종류가 다른 데이터형의 변환
                                      수치형   ----  정수형 (byte, char, short, int,long)
                                         ↑      ----  실수형 (float, double)
                                        (X)         
                      기본형          ↓ 
   자바                ↑            논리형   ---- boolean
                         (X)
데이타형             ↓
                     레퍼런스형   -  클래스 (String...)
                                       -  인터페이스
                                       -  배열
---------------------------------------------------------------------------------
[형변환 우선순위]
byte  → short  ↘
                          int  →  long → float → double 
            char   ↗

ex) int a=100;
     long b=a;         // a값을 long으로 형변환(자동)

     long a=123456;
     int b=(int)a;     // a값을 int로 형변환(강제)
---------------------------------------------------------------------------------
(2)상수
①논리형상수 : true/ false
②문자형상수 : '   '  (단일따옴표) - 문자    
                     "   "   (이중따옴표) - 문자열
    개행문자(New Line) : \n
    리턴(Return)           : \r  -- 커서를 맨앞쪽으로 이동
    탭(Tab)                  : \t  -- 8칸띄우기
    백스페이스             : \b
    null                       : \0 (아무것도없다)
③정수형상수
④실수형상수
----------------------------------------------------------------------------------
7. 데이터타입
(1) 기본형
    정수:  byte(1)   : -128 ~ + 127
             short(2)  : -32768 ~ +32767
             int (4)    : -2147483648~ +2147483647(default)
             long(8) 
    실수 : float(4)                  ex)float kk = 34.67f;
             double(8) - default
    문자 : char(2) : 0~65535    ex)char g='M';   char g='남';
    논리 : boolean    --->형변환 안됨(true/false)
           ex) boolean  sw = false;

(2)객체형(클래스)
     String :문자열
     ex) import java.io.*;  //예외처리   throws IOException
                                         또는 try{   }catch(IOException e);
           InputStreamReader sr = new InputStreamReader(System.in);
           BufferedReader s = new BufferedReader(sr);

           int a = Integer.parseInt(s.readLine());
           double b = Double.parseDouble(s.readLine());   "190.3"   --> 190.3
           float  c = Float.parseFloat(s.readLine());
           //객체형클래스 -> 기본형(wrapper클래스)


	ex) System.out.println("이름 : "+ name);
                  System.out.printf("이름 : %s" , name);   //jdk1.5버전 이상

             %s  :  문자열(String)
             %d  :  정수(byte, short, int, long)
             %f  :  실수(float, double)
             %c  :  문자(char)

             %-10s,   %5d,    %10.2f (자릿수 맞출때) 
====================================================
7. 연산자
(1)산술 : +, -, *, /,  %(나머지) - int형만 가능    
          ex)5 % 3 ===> 2  /  5 / 2 ===> 2  /   5.0 / 2 ===> 2.5

(2)관계 : ==, !=(같지않다), >=, <=, >, < 

          a=3(대입)    a==3(조건 ,비교)

	  ex) if(a==3)

(3)논리 : ||(or연산) ,    &&(and연산),      ! (not연산) 

(4)증감 : ++, --
          ex)  ++a;  --a;  (전치 : 연산후 사용)   // a=a+1동일 -> ++a표현
                a++;  a--;  (후치 : 사용후 연산)

            ex)   int  a=5;
                   System.out.println(++a);   ---> 6  (1증가  6을사용)

	     int  a=5;
                   System.out.println(a++);   ---> 5  (5를 사용하고 1증가)

             주의)     
                     ++5;              ---> 사용할수 X, 상수에는 사용할수 없다    

(5)대입 : =, +=, -=, *=, %=
         ex)              해석
          a += b;      a = a + b;
          a -= b;       a = a - b;
          a *= b;       a = a * b;
          a %= b;      a = a % b;

    ex)  int a=10;
          int b=5;
          a+=b;        ( a==> 15,  b==>5)
          

(6)비트단위논리연산: &, |, ^(Exclusive-OR), ~(0 <==>1)
    Shift연산자 : >>, <<

(7)조건(삼항) : 간단한 if문
             (형식)조건식?참일때:거짓일때;

               ex) int a=3;
                    String rs=(a==3)?"success":"fail";

(8)단항연산자 : - , +, ++, --, !
                  ex) -a     ++a     !a

     ex)   int a=-5;
            System.out.println(-a);     // 5    (-1 * -5 = 5)

            int a=-5;
            System.out.println(+a);     // 5    (+1 * -5 = -5)
  

[연산자의 우선순위]
( ) ---> 단항연산자 ---> 산술연산자 -> 관계연산자 ->논리연산자
          ! , +, -, ++, --      * , /  -> + , -                     && -> ||

ex)  5 + 2 * 3 = 11
      (5 + 2) * 3 = 21 
------------------------------------------------------------
예)  주소가 서울이거나 부산인 데이터 찾기(or조건  ,  || )
      서울         1              0      ===> true
      부산         0              1      ===> true  
      광주         0              0      ===> false
       (addr == "서울"   ||  addr =="부산")


예) 점수가  80이상 95미만인 데이터찾기(and 조건,  &&)
       97          1            0          ===> false
       55          0            1          ===> false
       85          1            1          ===> true
       (score  >= 80   &&   score < 90)
               80 <=  score  < 90          ====>   X
-----------------------------------------
★ASCII코드 (범위 : 0~125)   7bit
ex)    A   ---  1000001  -- 65
        B   ---  1000010  -- 66

A : 65   
a : 97
공백(space) : 32
경고음 : 7
Enter : 13                    
New Line : 10 (맨 앞줄로이동)
1  :  49
==========================================================
8. 제어문

(1) if문 / if ~ else 문 / if ~ else if....~else문  
     : 조건에 맞으면 실행하고 그렇지 않으면 실행하지 않는다

     i)if(조건식)    //실행문이 2문장 이상일때 반드시 { }해야함
       {
          실행문1;
          실행문2;
       }
       실행문3;

     ii)if(조건식)
          참일때; 
        else
          거짓일때;  

     iii)if(조건식)
            참일때;
         else if(조건식)
            참일때;
               :
         else
            거짓일때;

     
(2) switch(값)  <-- char, int, String (선택문)  ==> jdk 1.7이상
    {
       case 값1 : 실행문 ;  break;
       case 값2 : 실행문 ;  break;
                         :
                         :
       [default:]실행문;
    }

(3)while문(조건반복문)
① while(조건식)
   {
        실행문;       //조건이 만족하면 실행
   }
② do
   {
     실행문;          //실행한후 조건 비교
   }while(조건식); 


(4)for문(무조건반복문)
①단일for문
   for(초기값; 조건식; 증감식)
   {
   }
   ex) 
        for(int i=1; i<=10; i+=3)   // 1  4  7  10 
        {
        }
② 다중for문
   for(초기값; 조건식; 증감식)
   {
          for(초기값; 조건식; 증감식)
          {
          }
   }
③ forEach문
    for(자료형 변수 : 배열명)   // 데이타가 없을때까지 반복(jdk1.5이상)
   {
   }
④ break : 블럭탈출
⑤ continue: Loop문에서 더이상 이후 실행문을 진행할필요없이
                다음Loop를 진행시키고자 할때
============================================================
9. 메서드(Method) - 함수
   : 반복되는작업을 처리
     프로그램 수정,삭제가 용이하고 보기쉽다

(1)값에 의한 전달(Call By Value)
   - 기본데이타형  
    (byte, short, int, long, float, double, char, boolean)
(2)참조에 의한전달(Call By Reference)
   - 추상 데이터형 
     (배열, 객체)

[형식]
    접근지정자 결과형 함수명();
    -------        ------
      |          void, int ,float, double........   (void : 리턴값이 없다) 
      |
       public, private, protected	

     (결과형)
      return;          //생략가능
      return 변수; 
      return 수식;
      return  값;
     (주의 :  return은 1개만 가능)

      ex)  return a,b,c;      (X)
             return a;
             return 2+3;
             return "abc";

[유형]
1. static method(클래스메서드) : 객체생성없이 메서드를 호출
   형식)  ① 클래스명.메서드명
            ② 메서드명
            ③ 객체명.메서드명 

2. non-static method(인스턴스메서드) : 객체생성후에만 메서드가 호출
   형식) 객체명.메서드명 
============================================================
10. 배열
    : 자료형이 같은 데이타들의 모임
(1)1차원배열
    (형식)자료형[ ] 배열명;      or    자료형 배열명[ ];

 ex1)  int[ ] a;                  <-- 배열선언
         a = new int[5];       <-- 배열에 동적메모리할당(heap)

         a[0]=10;                 <-- 배열요소이용
         a[1]=20;
         ------------------------------------------------------
 ex2)   int [ ] a = new int[5];
         ------------------------------------------------------
 ex3)   int [ ] a;
           a = new int[ ] {1,2,3,4,5};
        -------------------------------------------------------
 ex4)   int [ ]a = {1,2,3,4,5};

(2)2차원배열
    (형식) 자료형[][] 배열명;    or   자료형 배열명[][];
               i)  int [][]data = new int[3][4];
               ii) int [][]data;
                   data= new int[3][4];
               ii) int [][]data={{10,40,70,100},{20,50,80,110},{30,60,90,120}};

(3)가변배열(참조형으로 처리)
     : 행 또는 면의 크기가 가변적인것

    (형식)자료형 [][]배열명 = new 자료형[첨자][];
          i) int [][]num = new int[3][];
	num[0] = new int[3];
	num[1] = new int[2];
	num[2] = new int[4];

          ii)int [][]num = new int[3][];
	num[0] = new int[]{1,2};
	num[1] = new int[]{3,4,5};
	num[2] = new int[]{6,7,8,9};

★참조형(Reference Type)
   : 기본형변수는 해당 변수가 위치한 곳에 값을 보관하고 있다.
     하지만 참조형은 값이 저장된 곳의 위치정보를 알고 있는 변수이다.
     결국, 기본형은 변수의 위치와 값이 저장된위치가 동일한 반면
     참조형은 값이 저장된 위치와 변수의 위치가 다르다. 
     참조라는 말은 주소(Address)라고도 말할수 있다. 
--------------------------------------------------------------------------------------------------------
★ 난수함수 : 컴퓨터가 임의의 수를 발생
① import java.util.Random;
② Random 변수1 = new Random();
③ int 변수2 = 변수1.nextInt(최대값); 
                   <-----  0 ~ (최대값 - 1)사이의 임의의 수
--------------------------------------------------------------------------------------------------------
★ 난수함수 
① Math클래스 이용
    - random()메서드를 이용 : 0 - 0.999999까지 
② ex) 
      System.out.println(Math.random());                     //0 - 0.9999999
      System.out.println((int)(Math.random()*10+1));      //1 - 10
//                                   0          0.999999
//                                   0          9.999999
//                                   1          10.999999
//                                   1          10 
                                      

★패키지(package)처리
$ javac  -d  .  파일명.java   <---컴파일
$ java   패키지명/파일명      <--- 실행
=========================================================
11. 객체지향프로그래밍(OOP : Object Oriented Programming)
  ★자바의 메모리구조
     : OS에 의하여 프로그램이 수행되면 JVM은 OS로부터 적절한 
       크기의 메모리공간을 얻어내게 된다. 그리고 얻어낸 메모리 
       공간을 JVM은 3영역으로 나누어 관리한다
   ① 메소드(method area)영역 : 메소드의byte코드 ,클래스의 전역변수,static 멤버변수
   ② 스택(Stack) : 매개변수, 지역변수 (메소드의 실행이 종료되면 자동반환)
   ③ 힙(Heap) : 클래스객체, 배열객체, 문자열객체
                        (new연산자 사용, 객체가 사용하는 메모리공간)


  ★객체지향의 중요한 3가지
    (1) 캡슐화(Encapsulation)
         :데이터보호, 재사용성  - 데이터은닉화
    (2) 상속성(Inheritance)
         :이미 만들어진 코드에 새로운 코드를 추가
          (프로그램 개발속도 증진, 프로그램 전체의 오류를 방지)
    (3) 다형성(Polymorphism)
         :상속받은것을 그대로 사용하지 않고 사용자 입맛에 맞게 바꾸어 사용
    
=========================================================
12. 함수 오버로딩(overloading)
     : 같은 이름의 함수를 여러번 구현할수있다.
       함수의 이름을 절약하기 위해 사용한다
       ① 매개변수의 갯수가 다름
       ② 매개변수의 자료형이 다름
       ③ 리턴타입은 오버로딩 성립에 영향을 주지 않는다

ex)  int add(int a){} 와 오버로딩이 되지 않는것은?
     1. int  add(int a ,int b){}
     2. void  add(float  a, float b){}
     3. void add(int k){}
     4. int add(char k){}
==========================================================
13. 생성자(Constructor) 
     :객체가 만들어지면서 자동호출하는 함수이며, 	
      객체의 초기작업을 할 경우에 이용 된다.

    ① 반드시 클래명과 동일해야 한다.
    ② 결과형(리턴값)이 없다 .
    ③ 객체가 생성될때 자동 호출되며, 사용자가 임의로 호출할수 없다
    ④ 멤버필드의 값을 초기화 한다
    ⑤ 생략하면 컴파일시 자동으로 default생성자를 만든다
    ⑥ 여러개의 생성자를 만들수 있다(생성자 overloading)
    ⑦ 생성자내부에서 첫번째라인에 this(매개변수)를 사용하여 다른 생성자를 호출할수 있다.
        단, 1번만 호출이 가능하다

       this()               ---> 자기 클래스의 디폴트생성자호출
       this(변수)         ---> 자기 클래스의 인자값을 가진 다른생성자호출  
       this.필드명       ---> 자기 클래스의 변수를 지칭
       this.메서드명()  ---> 자기 클래스의 메서드를 지칭

==========================================================
14. Garbage Collection
   : C언어의 소멸자 개념으로  new로 할당된 메모리를 JVM스스로 삭제한다.
     프로그래머는 신경쓸 필요 없다.
==========================================================
15. 다중 클래스
    : 하나의 파일에서 여러개의 클래스를 만들수 있음
      (단, public class는 하나만 존재, main()메소드가 있는 클래스에)
==========================================================
16. 오브젝트(클래스) 배열
<형식>     클래스명 []object명 = new 클래스명[첨자];
                object명[0] = new 클래스명(인자,인자..);
==========================================================
17. 상속(Inheritance)
    : 코드의 재사용 및 간결성을 위해 사용된다
      기존의 클래스(Super, Parent)라하고 확장하여 새롭게 정의한 
      클래스를 (Sub, Child)라 부른다. 다중상속 안된다.

      형식) class 부모클래스  
             {
             }
             class 자식클래스 extends 부모클래스  
             {
             }
          (다중상속이 안됨, 저장파일 : main이 들어있는 클래스명과 동일)
==========================================================
18. this예약어  
    : this예약어는 자신의 오브젝트를 가리키는 예약어
     ①자신의 오브젝트속에 존재하는 멤버변수를 가리킬때 
         <형식> this.멤버변수   <--주로 매개변수이름과 동일할때 구별목적으로 사용
                    this.메소드()
     ②생성자 내부에서 자신의 클래스의 또 다른 생성자를 지칭하는 메소드
         <형식>  this(값);    
          반드시 생성자속의 첫번째 문장으로 1번만 기재할수 있다
        

[참고] 
1. 메서드오버로딩(Overload Function)
   : 하나의 클래스에서 같은 이름의 메서드가 여러번 구현된경우
     (1) 메서드의 이름이 같아야 한다
     (2) 매개변수의 갯수또는 타입이 달라야 한다
     (3) 매개변수는 같고 리턴타입이 다른경우는 오버로딩이 성립되지 않는다
         (리턴타입은 오버로딩을 구현하는데 아무런 영향을주지 못한다)
    
      ex)  void  show(int a,int b)와  오버로딩인 메서드는? 2, 3, 4
           ①int   show(int a,int b);
           ②void  show(double a,double b);
           ③void  show(int a);
           ④int   show(char a);

2. 메서드오버라이딩(Override Function)
   : 선조클래스와 후손클래스에 같은 이름의 함수가 존재하는경우
     선조클래스로부터 상속받은 메서드의 내용을 변경하는것을 오버라이딩(재정의)이라고함
     (1) 이름이 같아야한다   
     (1) 매개변수의 갯수와 타입이 같아야한다
     (2) 리턴타입이 같아야한다
         (리턴타입이 다른경우는 overriding이 아님)
                 
      ex)  void  show(int a,int b)와  오버라이딩 메서드인 것은? 3
           ①int   show(int a,int b);
           ②void  show(double a,double b);
           ③void  show(int k,int s);
           ④int   show(char a);

=========================================================
19. 공유필드를 위한 static (this변수 없다)
      (1) static 필드 :데이타 값의 공유를 위해 선언하는 공간(멤버필드만 가능)
          ①클래스이름으로 접근가능
          ②객체발생전 메모리할당
           <형식> 클래스명.멤버변수  or  객체명.멤버변수   
      (2) static 초기화영역
           <형식> static {   초기화구문;  }
      (3) static 메서드 : static필드를 컨트롤할 목적으로 쓰임
==========================================================
20. final   
     ① final 필드 : 상수값이 저장될 공간으로 값이 변경될수 없음
                       (지역변수, 멤버필드 모두 사용가능)
           ex) final int a=10;
                a=20;           (X)

                final double PI=3.141592;
                final int PWD=1234;

     ② final 메서드 : 상속시 오버라이딩 되지 않아야할 메서드 지정
                          (overriding하게되면 error발생)
==========================================================
21. super의 사용 
     (1) 반드시 생성자속의 첫번째 문장으로 기재(1번만 기재)
     (2) 후손생성자속에서 선조생성자를 호출하면서 값을 올려줌
          super()  <--생략가능 
          super(인자,인자...) 
          super.메소드() 
===========================================================
22. 접근지정자 
(1)private : 하나의 클래스내에서만 사용가능한 멤버지정
(2)package(아무것도 기재하지 않음, default라고도 함)
    : 동일파일 + 동일폴더
(3)protected : 동일파일 + 동일폴더 + 상속
(4)public : 객체를 가진 모든 영역
public >  protected > default(생략) > private

                           같은패키지                        다른패키지
-------------------------------------------------------------------------
                    같은클래스 |다른클래스 |  상속      클래스 | 상속
--------------------------------------------------------------------------
public                O               O              O              O       O
protected           O               O              O              X        O
default(생략)       O               O              O              X        X
private               O               X              X              X        X
========================================================
23. abstract class (추상 클래스-미완성)
(1)추상클래스
  ①추상클래스(abstract class)란?
    - 내용이 구현되어 있지 않는 메소드가 1개라도 존재하면 추상클래스라고 함
       ex) public void view() { }               -- 구현O
            abstract public void view();       -- 구현X
    - 추상메서드가 없어도 추상 클래스를 만들수 있다
    - 자기자신으로 객체 생성이 불가능
         ex) ABC  ob = new ABC();           ---- 객체생성X

    - 하위클래스들이 특정메소드(추상메소드)를 반드시 강제 overriding 하기 위함이다
    - 추상클래스를 사용하는 이유 : 메서드의 일관성을 유지하기 위해서이다

   ②추상클래스 사용방법
      : abstract키워드를 사용한다.
     <형식>   abstract class 클래스 이름{
                          abstract 리턴타입 추상메소드이름();
                   }
==========================================================
24. 예외처리 
     : 비교적 가벼운 에러로 에러 발생할것을 미리 예측하여 처리하는것
      1. Unchecked Exception : 필요한 경우 예외처리 수행
           - ArithmeticException, NullPointException, ArrayIndexOutOfBoundsException
      2. Checked Exception : 강제로 예외처리를 수행
           - IOException,FileNotFoundException

① throws 예약어 : 예외객체를 양도
     <--- 예외상황을 다음 문장으로 전가
② try{   }catch{   } : 예외가 발생하면 예외객체를 잡아내어 원하는 동작을 수행
     <-- 예외상황을 처리하고 다음문장 수행
③ try{   }catch{   }finally{   } : 예외가 발생하든 안하든 finally는 무조건수행
            [참고] return 을 해도 finally는 수행
④ throw  : 예외강제발생

Exception :  모든 예외상황
IOException : 입.출력에 관련된 예외
NumberFormatException : 숫자가 아닌 문자가 입력되는 예외
ArithmeticException : 0으로나누는 예외
ArrayIndexOutOfBoundsException : 배열초과
=========================================================
25. 다형성(polymorphism)
    : super(부모)클래스와 sub(자식)클래스에 동일한 이름의 함수가 
      존재(Overriding)할 경우 super클래스의 참조변수로 sub클래스의 
      인스턴스를 참조할수 있다
=========================================================
26. 인터페이스(Interface): 다중상속가능
     : 자바는 단일상속만 지원하는데 이 단점을 보완하기 위해 나온 것       

       조건) 1. 추상클래스와 달리 모든 메소드가 추상메소드이다. 
               2. 모든 변수가 final이어야 한다  
       사실, 인터페이스를 사용하는 가장 큰 목적은 다형성이다.

  (1) 인터페이스의 특징.
          
                 클래스        인터페이스
       ------------------------------------------
       키워드  class             interface
       상속    extends         implements
       함수    일반,abstract  abstract(모두다)
       변수    일반,final       final(모두다)
       상속    단일상속        단일,다중상속     
       abstract  생략X          생략O
       final       생략X          생략O
       --------------------------------------------                
       - class 대신에 interface 키워드 사용.
       - 멤버변수는 상수로 선언.즉 final 키워드를 사용한다는 것이고   변경할 수 없다(final은 생략가능.)
       - 멤버메소드는 몸통이 없음.즉 abstract메소드이고 모든 메소드가  abstract이므로 생략가능.
       - 부모의 인터페이스를 상속받을시는 extends 대신 implements 키워드 사용.
   (2)인터페이스 형식
        public interface 인터페이스이름{
                 상수선언. 상수선언이라 함은 final 키워드를 쓰는것.
                 이름뿐인 메소드 선언
        }
======================================================
27. instanceof연산자
   : 상속관계에서 부모와 자식관계인지 여부를 판단하는 연산자이다.
     다른형태의 하위객체들이 한 부모를 상속받았을 경우에 어떤 클래스 인지 알아낼수 있다

    [형식]  객체명 instanceof 클래스명

    ex)  AA  a  <----- BB  b
                    <----- CC  c    BB,CC가 모두 AA를 상속받았을 경우

         if( c instanceof  AA)      ==> true        (부모 has-a 자식)
         if( b instanceof  BB)      ==> true
         if( c instanceof  BB)     ==>  error
         if( a instanceof  CC)     ==> false
==========================================================
28.자바의 중요한 클래스 
(1)String 클래스
     : 불변객체(immutable)
       String 변경메서드를 호출한다는것은 새로객체를 생성한다는 뜻이다

   ①concat(str):str로 설정된 문자열결합
   ②substring(n1,n2):n1과 n2 사이의 문자열 반환
   ③toUpperCase():대문자로바꾸기
   ④equals():문자열비교        <----중요!!
   ⑤charAt():특정위치의 문자를 리턴
 
(2)StringBuffer클래스
    : 가변객체(mutable)
      Buffer를 두어 문자열 연산을 하여, 속도가 빠르다

   ①append() :추가
   ②reverse() :꺼꾸로출력
   ③delete()  :삭제
   ④length()  :문자열의길이
   ⑤capacity():버퍼의size (기본:16byte)

(3)StringTonkenizer클래스                                        
   ex)127.0.0.1#9000#뽀로로#안녕~~
   ①countTokens() : 문자열에 있는 토큰의 갯수반환
   ②nextToken()   : 다음 토큰 문자열을 반환
   ③hasMoreTokens():토큰이 있으면 true,없으면 false반환

(4)Calendar클래스
   :날짜나 시간을 나타내는 클래스

(5)Random클래스 : import java.util.Random
   : 임의의 난수 발생
  ①Random 변수1 = new Random();
  ②int 변수2 = 변수1.nextInt(최대값); 
=========================================================
29. Collections(컬렉션)
   1) Collection Framework이란 
      다수의 데이터를 쉽게 처리할수 있는 표준화된 방법을 제공하는 클래스들
      크게 List, Set, Map의 3가지 타입의 컨테이너를 제공한다
   2) Collection특징
      - 객체를 저장할때마다 크기가 자동으로 늘어난다
      - Set계열 : 중복을 허용하지 않고,추가되는 순서를 유지하지 않는다
        List계열 : 중복을 허용하고, 추가되는 순서를 유지한다
        Map계열 : 키와 값의 쌍으로 저장된다(키와 값이 모두 객체이어야 한다)
        (java.util   package에 있다)
   3) 배열과 Collection
       구분               배열                                      컬렉션
       ----------------------------------------------------------------------------------------------
       장점         - 객체를 저장하는데 가장효율적      - 자동으로 크기조절
                      - 사용상의 편의성                       - 객체 저장시 다양하고 편리한 기능제공
                                                                      표준화된 interface 기반설계
       -----------------------------------------------------------------------------------------------
       단점         -고정된 크기만 제공                    - 다소 복잡한 사용방법

    4) 제네릭스
        Heterogeneous의특징을 갖는 Collection을 Compile-time type에 안전함과 cating에 대한
        불편함을 없애기 위해 Homegeneous한 형태로 바꾸는 새로운 타입이다
        자바에서 타입에 관련된 것은 제네릭스와 연관을 갖는다
        (도입배경)
            - Collection클래스에 서로 다른 객체를 저장하는 것에 대한 제한불가
            - 컴파일 하는 도중 타입 확인이 불가능하다
            - 저장된 객체를 사용시에는 반드시 캐스팅해야한다
              (ClassCastException과 같은 런타임 오류를 발생)
         (제네릭스의 특징)
             1. Collection 선언시에< >안에 매개변수타입을선언, 컴파일러에게 사용타입을 전달
             2. 캐스팅이 필요없고, 보다 안전한 코드를 작성할수 있다
             3. 메소드가 받아들일수 있는 타입을 제한 함으로써 에러검사, 타입검사를 생략할수 있다
             4. java.util패키지의 컬렉션클래스 들은 기본적으로 제네릭스를 지원한다
             5. 매개변수 타입에는 primitive타입을 사용할수 없다

(1)Set인터페이스   
     1)HashSet
         - Set에 객체를 저장하는데 Hash를 사용하여 처리속도가 빠르다
     2) LinkedHashSet
         - HashSet과 거의 같다.차이점은 Set에 추가되는 순서를 유지한다는것
     3)TreeSet
        - 객체의 Hash값에 의한 오름차순의 정렬을 유지한다

(2)List인터페이스 
    List인터페이스로 구현된 클래스로 ArrayList, Vector, Stack, LinkedList가 있다
   1) List
      - List의 요소에는 순서를 가진다
   2) ArrayList
      -자바에서는 배열을 생성할때 배열의길이를 늘리거나 줄일수없다.
      -ArrayList클래스는 원소가 가득차게되면 자동적으로 저장영역을 늘려준다 
      - List에서 객체를 얻어내는데 효율적이다
      - 동기화(synchroniztion)을 제공하지 않는다
   3) LinkedList
      - List에서 앞뒤에 데이터를 삽입하거나 삭제하는데 효율적이다
       -동기화를 제공하지 않는다
   4) Vecter
      : 가변배열을 처리하는 클래스   
       배열(Array)은 고정길이를 사용하기 때문에 길이를 늘리거나 줄일수 없다
       Vector클래스를 사용하면 배열의 크기를 늘리거나 줄일수 있다.
       기본적으로 ArrayList와 동등하지만 Vector에서는 동기화를 제공한다
       그래서 List객체중에 가장 성능이 좋지 않다

   (형식) Vector<자료형> 객체명  = new Vector<자료형>(첨자,첨자);
                                                                         초기값,늘릴갯수

            ex) Vector<String> ss=new Vector<String>(3,2);

   ①hasMoreElements():백터안에서 꺼낼 객체가 있으면 true, 없으면 false
   ②nextElement() : 백터에서 객체를 가져옴
   ③elements()      : 백터요소들에 대한 Enumeration객체를 반환
   ④capacity()        : 현재 용량
   ⑤size()              : 현재data의 갯수
   ⑥addElement()   : data추가
   ⑦indexOf()         : 찾는위치
   ⑧contains()        : 비교
   ⑨remove()         : 삭제
   ⑨trimToSize()     : 빈공간제거
   
(3)Map인터페이스
   1)HashMap
       - 해쉬테이블처럼(키와 객체)쌍으로 저장 관리할수 있다.
       - Map에 키를 저장하는데 hash를 사용하여 성능이 좋다
       - 저장되는 순서를 유지하지 않는다
       - 오직 하나의 null키를 가질수 있다
       - key의 중복을 허용하지 않는다
   2)LinkedHashMap
       - HashMap과 거의 같다.차이점은 Map에 추가되는 순서를 유지한다는것
   3)HashTable
       - 자료를 테이블 구조로 쉽게 저장할수 있고, 검색할수 있는 클래스이다
       - Hashtable클래스는 Vector클래스에서 사용한 Enumeration인터페이스를 
         사용해 값을 가져올수 있다
       - 동기화를 제공한다. null키와 null값을 저장할수 없다
(4)Iterator(반복자)인터페이스
    리스트는 원소를 순차적으로 접근하기 위해서 for문을 이용하지만,
    반복자를 이용하여 원소에 접근할수 있다. 
    모여있는 자료들을 검색하여 처리하는 패턴

(5)Enumeration인터페이스
    Collection인터페이스로 부터 구현한 클래스안에 저장된 객체를 꺼낼수 있다
    ① hasMoreElements() : 요소가 있으면 true반환
    ② nextElement()     : 요소를 얻어낸다
  
(6) AutoBox/AutoUnBoxing
     : primitive type과 Wrapper Class타입간 형변환을 자동화
       Collection에 primitive 타입을 넣고 빼는 경우에 유용함
====================================================================
30. AWT (Abstract Windows Toolkit)
    : GUI(Graphic User Interface)환경의 프로그램을 작성하기 위한 패키지

 ①컴포넌트 :사용자 인터페이스를 구성하는 기본요소
                  버튼, 체크박스, 레이블, 텍스트필드, 리스트, 팝업메뉴와 같은 부속품의 총칭
                  자바에서는 component라는 클래스가 있는데 모든 컴포넌트들은 
                 이 Compont 클래스의 자손이다.
 ②컨테이너 : 컨테이너는 컴포넌트들이 붙어 있는 윈도우 같은 것
                  윈도우, 프레임, 패널, 다이얼로그 박스 등이 있다.  
                  (다른 컴포넌트를 담을수 있는 컨테이너)
 ③레이아웃 : 컨테이너에 컴포넌트를 붙일때 어떤 식으로 배치하는가가 중요한데 
                   이것을 레이아웃이라 한다
 ④이벤트 : 사용자로부터 입력이 일어나는 것

  >컴포넌트 순서<
    ① 컴포넌트 생성   예) 버튼모양 만들기
    ② 컨테이너 부착
    ③ 이벤트 처리

[1] AWT 클래스 구조
   -----------------------------------------------------------
    Object   -  Component  - Button
                                      Label
                                      List
                                      Choice
                                      Checkbox
                                      Scrollbar
                                      Canvas
             -  TextComponent  - TextField
                                           TextArea
             -  Container      - Panel      - Applet
                                    - Window   - Frame
                                     - Dialog    - FileDialog
   ------------------------------------------------------------
import java.awt.*;     <----클래스 지원

[2] Panel (패널)  : Container에 담을수 있다.

[3] Layout
  (1) 레이아웃 매니저
    : 컴포넌트를 적절한 위치에 배치할 수 있도록 하기 위해 레이아웃 매니저를 제공.
  (2) 레이아웃 매니저의 종류
      : FlowLayout, GridLayout, BorderLayout, CardLayout, GridBagLayout,null

   ①FlowLayout - 왼쪽에서 오른쪽으로,위에서 아래로 순서대로 배치하는 단순한 레이아웃
   ②GridLayout - 가로,세로 비율을 나누어 공간(셀)에 배치(모눈종이와같은모양)
   ③BorderLayout - 동, 서, 남, 북, 중앙으로 화면을 분할
   ④CardLayout - 여러개의 카드를 쌓아둔것처럼 보여주는 배치관리자 
   ⑤GridBagLayout - 가장복잡한 레이아웃
   ⑥null - 레이아웃 매니저를 이용하지 않고 좌표를 지정하여 붙인 예제

  (3) 레이아웃 매니저를 사용법.
        setLayout(new FlowLayout());//Container 클래스의 메소드 
  (4) 각 레이아웃의 기본.
       - FlowLayout - Panel이나 Applet의 기본 레이아웃.
       - BorderLayout - Frame과 Dialog의 기본 레이아웃.

[4] 이벤트
    : 마우스나 키보드등을 이용해서 사용자로부터 입력이 일어나는것
    1)이벤트소스 - 이벤트를 발생시킨 윈인이 되는 컴포넌트
    2)이벤트클래스
    3)이벤트핸들러- 해당하는 이벤트가 실행되었을때 실행될루틴

    ※발생시키는 이벤트

    컴포넌트             발생시키는 이벤트클래스
   ----------------------------------------------------------------
    Button               ActionEvent
    Checkbox             ItemEvent
    CheckboxMenuItem     ItemEvent
    Choice               ItemEvent
    Component            ComponentEvent, FocusEvent, KeyEvent, MouseEvent
    Container            ContainerEvent
    List                 ActionEvent, ItemEvent
    MenuItem             ActionEvent
    Scrollbar            AdjustmentEvent
    ScrollPane           AdjustmentEvent
    TextComponent        TextEvent
    TextField            ActionEvent
    Window               WindowEvent
   ====================================================================
   ※이벤트리스너

   이벤트클래스         리스너인터페이스      리스너메소드
   -----------------------------------------------------------------------------------
   ActionEvent         ActionListener        actionPerformed(ActionEvent e)
   ------------------------------------------------------------------------------------
   AdjustmentEvent     AdjustmentListener    adjustmentValueChangeed(AdjustmentEvent e)
   ------------------------------------------------------------------------------------
   ComponentEvent      ComponentListener     componentHidden(ComponentEvent e)
                                             componentMoved(ComponentEvent e)
                                             componentResized(ComponentEvent e)
                                             componentShown(ComponentEvent e)
   ------------------------------------------------------------------------------------
   FocusEvent          FocusListener         focusGained(FocusEvent e)
                                             focusLost(FocusEvent e)
   ------------------------------------------------------------------------------------
   ItemEvent           ItemListener          itemStateChanged(ItemEvent e)
   ------------------------------------------------------------------------------------
   KeyEvent            keyListener           keyPressed(KeyEvent e)
                                             keyReleased(KeyEvent e)
                                             keyTyped(KeyEvent e)
   ------------------------------------------------------------------------------------
   MouseEvent     MouseListener  mouseClicked(MouseEvent e)
                                             mouseEntered(MouseEvent e)
                                             mousePressed(MouseEvent e)
                       ----------------------------------------------------------------
                                             mouseReleased(MouseEvent e)
                       MouseMotionListener   mouseDragged(MouseEvent e)
                                             mouseMoved(MouseEvent e)
   ------------------------------------------------------------------------------------
   TextEvent           TextListener          textValueChanged(TextEvent e)
   ------------------------------------------------------------------------------------
   WindowEvent         WindowListener        windowActivated(WindowEvent e)  //윈도우활성화
                                                              windowClosed(WindowEvent e)     //윈도우최소화  
                                                              windowClosing(WindowEvent e)    //윈도우종료     
                                                              windowDeactived(WindowEvent e)  //윈도우비활성화
                                                              windowIconified(WindowEvent e)  //윈도우아이콘화 
                                                              windowDeiconified(WindowEvent e)//윈도우아이콘해제
                                                              windowOpened(WindowEvent e)     //윈도우열기
   ==================================================================================
   ※이벤트클래스설명

   이벤트클래스                         설   명
   ------------------------------------------------------------------------
   ActionEvent           버튼이 눌러졌거나 텍스트필드의 입력이 완료되었을때, 
                         메뉴의 항목이 선택되었을 때, 
                         리스트의 항목이 더블클릭 되었을때 발생.
   ------------------------------------------------------------------------
   AdjustmentEvent       스크롤바의 버블이 움직일때 발생.
   ------------------------------------------------------------------------
   ComponentEvent        컴포넌트의 위치나 크기가 변경되었을 때, 
                         또는 컴포넌트가 나타나거나 숨겨질 때 발생
   ------------------------------------------------------------------------
   ContainerEvent        컴포넌트가 컨테이너에 추가되거나 삭제되었을때 발생
   ------------------------------------------------------------------------
   FocusEvent            컴포넌트가 키보드로부터 입력을 받아들이기 위한 포커스를 
                         획득하거나 잃었을때 발생. 
   ------------------------------------------------------------------------
   ItemEvent             체크박스나 초이스, 
                         리스트의 항목이 선택(한번클릭) 되었을 때 발생
   ------------------------------------------------------------------------
   KeyEvent              키보드로부터 입력이 있을때 발생
   ------------------------------------------------------------------------
   MouseEvent            사용자가 마우스 버튼을 누르거나 놓을때, 
                         마우스가 컴포넌트 위로 들어가거나 나올 때, 
                         또는 사용자가 마우스를 이동하거나 드래그 할때 발생
   ------------------------------------------------------------------------
   TextEvent             입력된 텍스트에 변경이 일어날때 발생
   ------------------------------------------------------------------------
   WindowEvent           윈도우가 열리거나 닫힐 때, 최소화하거나 최대화 할때, 
                         윈도우 메뉴가 선택될 때 발생

===========================================================================
31. IO (Java의 input/output)

(1) 입.출력의 정의
: 외부에서 프로그램으로 들어오는 일을 입력이라고 하고 반대로 프로그램에서 나가는 일을 출력이라고 한다.
   입출력 장치
     - 파일, 디스크
     - 키보드, 모니터, 마우스
     - 메모리
     - 네트워크

(2) Stream(스트림)의 이해 
   ① 자료의 입출력을 도와주는 중간 매개체로써 스트림은 데이터를 읽고 쓰기위한 공통된 방법을 제공한다. 

   ② 노드스트림(=바이트스트림): 데이터 저수지에 직접연결되어 있는 부분으로 대표적인 
       입력노드스트림은 InputStream. 출력스트림은 OutputStream

   ③ 필터스트림(=문자스트림): 예로 노드스트림을 통해 한글데이터를 직접가져올 경우 모두 
       깨져버리는데 깨지지 않도록 필터스트림을 주는데 대표적인 입력 필터 스트림은 Reader , 
       출력 필터 스트림은 Writer가 있다. (ex. InputStreamReader,  OuputStreamWriter)
       또다른 예로, 프로그램을 읽을때마다 노드스트림을 통해서 파일 등에 접근하기 때문에, 
       당연히 기다려야 하는 문제가 생길수밖에 없는데 이럴때 사용하는 것이 BufferedReader등이 있다
       이들은 필터스트림의 생성자에 노드스트림의 객체를 주어서 사용한다.

   ④ 스트림은 크게 두가지로 나눌 수있다. 
       문자 스트림 : 문자 단위로 처리함
               - Reader : 입력용 문자 스트림
               - Writer :   출력용 문자 스트림
               - Reader나 Wrtier가 붙으면 문자스트림이라는 것을 알 수 있음

       바이트 스트림 : 바이트 단위로 처리함
               - InputStream or OutputStream


(3) 각 노드스트림에 연결할 수 있는 필터스트림이 따로 있는데 다음과 같다.

   	노드스트림	관련된 리더(캐릭터단위)	관련된 버퍼
--------------------------------------------------------------------------------------    
입력	InputStream	InputStreamReader	          BufferedReader
	FileInputStream	FileReader	          BufferedReader
	FilterInputStream	FilteredReader	 
	DataInputStream	 	 
----------------------------------------------------------------------------------------
출력	OutputStream	OutputStreamWriter       BufferedWriter
	FileOutputStream	FileWrtier	                      BufferedWriter 
	FilterOutputStream	FilterWriter	 
	DataOutputStream	 	 
             PrintStream	PrintWriter

2. 입력스트림

2-1.InputStream과 InputStreamReader
: 데이터를 외부기억장치로부터 읽어 들일때 사용하는 스트림으로 InputStream, 
  FileInputStream 클래스와 같은 노드 스트림이 있고, 노드 스트림에 연결해서 
  사용하는 리더(Reader)와 버퍼 등과같은 필터 스트림이 있다.

Input(읽어오는 것):
시스템으로부터 읽어오는 것->InputStream

InputStream 은 byte 단위, InputStreamReader는 character 단위(한글,중국어등 안깨짐)
ex) 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class InputEx1 {
	public static void main(String[] args) throws IOException {
	InputStreamReader isr=new InputStreamReader(System.in);
	BufferedReader br=new BufferedReader(isr);
	String name=br.readLine();
        int age=Integer.parseInt(br.readLine()); //11 입력시 int 로 변환하여 치환
	char gender=br.readLine().charAt(0); //입력의 첫글자만 치환
               (ㄴ ex '남' 입력시 실제입력스트림 값은 '남\n\r' 이라서 string 값이므로 0번째
                char 값인 '남' 값만 읽어서 치환)
}}
  *) I/O 스트림 사용시 함수 아규먼트 괄호 뒤에 throws IOException 추가


2-2 .FileInputStream과 FileReader

: FileInputStream은 InputStream의 서브클래스로 파일로부터 바이트 단위로 읽는 입력스트림이다.
  캐릭터 단위로 읽으려면, FileReader 클래스를 사용하면 된다.

==> 주의할점은 파일로부터 캐릭터 단위로 읽는 입력 스트림의 이름이 FileInputStreamReader가
       아니고 FileReader라는점이다.


3. 출력스트림
3-1. OutputStream 과 OutputStreamWriter
: 프로그램에서 외부 기억장치에 데이터를 내보낼때 사용하는 스트림. OutputStream 클래스는 
  바이트 단위로 데이터를 출력하기 때문에, 한글과 같은 문자를 출력하려면 캐릭터 단위로 
  출력하는 OutputStreamWriter 클래스를 연결해서 사용.

========================================================================
32. 객체직렬화

(1) 객체직렬화의 개념
  객체의 내용 -> 바이트 단위로 변환 -> 파일 또는 네트워크를 통해서 송수신(스트림)이 가능하게 만들어 주는 것
  (멤버변수만으로 구성)

 String 과 int 형인 멤버변수를 가진 클래스를 컴파일을 시키고 실행을 하면 각 변수에 값이 대입되면서 
자바가상머신의 메모리에 자리를 잡는다. 이때 컴의 전원을 끄거나 한다면 이 변수의 값은 사라지고 만다
하지만 이 값을 영구 보존을 한다던지 누군가에게 이 값을 그대로 전달하고자 한다면 객체직렬화를 사용해야 한다. 
실행되어서 생성된 값을 가진 클래스 객체를 직렬화 해서 파일에 저장을 한다던지 네트워크를 통해서 전달하면 
그 객체의 값(멤버변수의 값)은 그대로 복원되어 사용할 수 있다

(2) 장점
   ① 객체를 파일에 저장함으로써 영속성을 제공
   ② 객체 자체를 네트워크를 통하여 손쉽게 교환 가능

(3) 사용하는 이유(RMI와 Bean 때문)
   ① RMI는 원격객체통신을 지원해야 하기 때문에 객체가 그대로 이동할 수 있어야 한다. 
        따라서 이를 지원하기 위해서 객체직렬화가 필수이다. 
   ② Bean은 설계시 상태에 대한 정보를 지정할때 이 객체직렬화를 사용하면 편하게 객체 상태를 저장할 수 있다. 
       그 외에도 네트워크 프로그램이나 파일 프로그램에서 객체직렬화를 사용하면 작업이 수월하게 된다

(4) 종류
★Serializable 인터페이스와 ObjectInputStream 클래스,ObjectOutputStream클래스
   객체 직렬화를 하기 위해서 먼저 객체를 객체직렬화가 가능하도록 Serializable 인터페이스를 구현해야 한다.
   그리고 ObjectInputStream 클래스와 ObjectOutputStream클래스는 객체를 입출력을 하기 위해 사용되는 클래스이다. 
   이들은 다 java.io 패키지에 정의되어 있다

   1> Serializable 인터페이스
       객체 직렬화를 하기 위해서 먼저 객체를 객체직렬화가 가능하도록 Serializable 인터페이스를 구현해야 한다
       이 인터페이스는 객체직렬화가 제공되어야 함을 자바가상머신에 알려주는 역활을 한다
       Serializable 인터페이스는 다른 인터페이스와는 달리 구현해야 할 메서드가 없으므로 단지 선언만 해주면 된다

   2> ObjectInputStream 클래스
       ObjectInputStream 클래스는 파일에 저장되어 있는 객체 또는 네트워크를 통해 직렬화되어
       전달된 객체를 직렬해제 하는 기능을 제공해 주고 있다. 한가지 주의할 점은, java.io.Serializable 인터페이스와 
       java.io.Externalizable 인터페이스를 지원해 주는 객체에 대해서만 가능하다는 것인데, 
       이는 등록된(즉 Serializable 인터페이스와 Externalizable 인터페이스를 구현한 클래스 객체) 객체를 말한다. 
       이때, readObject 메소드를 이용하여 스트림으로부터 직렬화된 객체를 읽을 수 있다. 
       그리고, 이렇게 읽은 객체는 배열, 문자열, 또는 각 객체 등 원래의 형으로 캐스팅 해 주어야 한다

   3> ObjectOutputStream 클래스
       ObjectOutputStream 클래스는 객체들을 출력하는 기능을 제공해 주고,출력 스트림에 출력하기 전에 직렬화를 수행한다.
       ObjectOutputStream 클래스는 자바 기본형 데이터 또는 객체들을 파일에 저장하거나 네트워크를 통해 전달하기 위해 
       전달할 객체를 직렬화하는 기능을 제공해 준다. 
       이 클래스도 역시 ObjectInputStream 클래스와 마찬가지로 java.io.Serializable 인터페이스와 java.io.Externalizable 
       인터페이스를 구현한 객체에 대해서만 가능하다. 
       이때, writeObject 메소드를 이용하여 스트림에 직렬화된 객체를 출력할 수 있다

★Externalizable 인터페이스
   -Serializable 인터페이스의 하위 인터페이스로서 보다 효율적인 직렬화를 위해서 사용된다.

★transient 키워드
   -객체직렬화시 transient 키워드는 저장할 필요가 없는 멤버 변수를 지정할 때 사용된다.

(5) Key Point
객체 직렬화 : 객체를 한 줄로 늘어선 바이트 형태로 만드는 것 ---> 전송이 가능해짐
                   여기서 객체란 값이 할당된 멤버변수로만 구성되고 객체 직렬화에서 메서드와 생성자는 제외됨 
객체를 이용한 메서드 호출 : 객체가 보유하고 있는 값과 메서드의 형태를 알면 호출가능
객체 직렬화의 사용 : 객체 자체를 저장(영구보존)하거나 네트워크를 통해 전송하는 경우 
객체 직렬화의 장점 : 객체 영구보존 가능. 데이터의 복구 가능해 진다. 

=========================================================================
33. 쓰레드(Thread)
1-1. 프로세스 : 특정한 작업을 처리하기 위해 메모리에 적재되어 있는 프로그램
1-2. 멀티 프로세스 : 여러가지 작업을 동시에 하는 것으로 음악을 들으면서
                          채팅도 하고 파일을 다운로드 받는 작업을 동시에 할 수 있다.

1-3. 쓰레드 : 프로세스 내부에서 독립적인 작업을 처리하는 명령어의 집합.
1-4. 멀티 쓰레드 : 채팅을 예로 들어서, 다운로드 받는동시에 대화를 주고 받으며 
                            상대방이 글을 쓰고 있든 아니든 글 을 쓸 수 있다.

2. 쓰레드를 사용하는 이유
: 동시에 두가지 이상의 작업을 처리할 때. 대표적인 예로 웹서버와 채팅.

3. 쓰레드를 사용하는 방법
① Thread클래스를 상속받는 경우
② Runnable 인터페이스를 implements하는 경우

4. Thread클래스를 상속받는 쓰레드 이용하기.
① Thread클래스를 상속받은 후 run() 메소드를 원하는 작업을 하도록 오버라이딩
② 완성된 클래스를 생성한 후 start() 메소드를 실행

5.Runnable 인터페이스를 implements하는 쓰레드 이용하기
: 이미 다른 클래스를 상속받아서 Thread 클래스를 상속받아 쓰레드를 생성할 수 없을때 , 
  Runnable 인터페이스를 이용한다.

① Runnable 인터페이스를 상속 받은 후 run() 메소드를 원하는 작업을 하도록 구현
② 완성된 클래스를 생성한 후, Thread 클래스의 생성자에게 인수로 전달


**. 쓰레드의 상태
: 쓰레드는 생성상태, 실행중인상태,대기(실행중지상태), 완료상태를 가진다.

1)생성상태
:실질적으로 쓰레드를 실행중인 상태로 전이하기 위해서는 start() 메소드를 이용해야 한다. start()메소드를 호출하면 쓰레드를 실행하기 위해 run()메소드를 호출한다.

-> start()

2) 실행중인 상태
: 새로운 스레드가 생성되어 그 스레드의 start 메소드를 호출하면, 
  스레드는 실행 가능한 Runnable 상태가 되는데, 실제로 Runnable 상태는 두 가지로 나뉘게 된다.
  CPU를 차지한 스레드가 있을 것이고 실행권한을 가진 후보(候補)스레드가 있게 됩니다. 
  보통 이러한 것은 실행 큐라고 하는 것에 스레드를 넣어두고 자바런타임 스케쥴러에 의해서 
  처리되게 된다. 
  실행큐란 Runnable상태에 있는 스레드들을 넣어두는 자료구조입니다. 알고 보면 CPU는 한순간에 단 하나의 스레드만을 실행할 수 있습니다. 실행큐에 있는 스레드들 중에서 하나만을 골라서 실행하는데 거의 번갈아가면서 실행을 하는 것이다. 
그래서 실행큐에 들어 있는 스레드를 Runnable상태에 있다라고 말한다. 


물론, 단 하나의 스레드만이 실행스레드이고 나머지는 후보스레드이다
보통의 경우는 스레드를 이렇게 나누지만 두 가지 경우 모두 Runnable상태이다

- sleep()메소드 호출: 지정된 시간동안 쓰레드를 쉬게 한다.
- wait()메소드의 호출 : 현재의 쓰레드를 기다리게 한다.
- suspend)메소드의 호출 : 쓰레드의 실행을 일시적으로 중단시킨다.
- 입출력 작업을 하기 위해 대기하는 경우

3) 대기(실행중지상태)

-sleep()메소드 호출에 의한 경우는 지정된 시간이 지나야 한다.
-wait()메소드 호출에 의한 경우는 notify()나 notifyall() 메소드 호출
-suspend() 메소드 호출에 의한 경우는 resume() 메소드가 호출되어야 한다.

*** suspend(), resume(), stop()메소드를 사용하지 말라고 권고 ***
==========================================================
34. 네트워크

1. IP : 숫자 형태
             미국        000.000.000
             대한민국  000.000.000.000 
: 32bit 주소 (IPv4)
  8비트씩 끊어서 표현(0 ~ 255) - 포화상태

  128bit (IPv6) 
  16비트씩 8부분으로 나누어 표현
  

2. Domain : 접속 안됨
	  DNS - Domain Name System
               (IP주소를 도메인 이름으로 바꾸어 주는 시스템)


3. port : 0 ~ 65535 까지 사용
           0~1024  까지는 시스템에 의해 예약
           80 : HTTP
           21 : FTP
           23 : TELNET


4. 프로토콜
: 서버와 클라이언트간의 통신규약
: 대표적인 프로토콜 - TCP, UDP

# TCP                
: 연결 후 통신(전화기)
: 신뢰성있는 데이터 전송
: UDP보다 느림
: Socket, ServerSocket

# UDP
: 연결없이 통신(우편)
: 1:1 , 1:다, 다:다 
: 신뢰성 없는 데이터 전송
: TCP보다 빠름
: DatagramSocket

5. URL(Uniform Resource Locator) : 인터넷 접속시
  프로토콜://Domain:port/파일
                     ↓
                    IP

[ex] http://www.naver.com:80/index.html 
(파일명이 index인 경우에는 생략 가능) 
IP = 202.131.29.71

     http://202.131.29.71:80/index.html (파일명이 index인 경우에는 생략 가능)
     ftp://
     rmi://

SK     서버               host
나     클라이언트      local host


☆채팅 프로그램★

- 동기적 처리 방식

1. ChatServer.java  먼저 실행

        ChatServer(서버) 
            ServerSocket - 클라이언트가 들어오기를 기다린다.
                         - 클라이언트가 들어오면 낚아채서(accept);
                           클라이언트와  통신할 소켓을 생성해준다.

   소켓 	 소켓         소켓        → Thread
 ChatHandler   ChatHandler  ChatHandler





   소켓         소켓           소켓
클라이언트     클라이언트     클라이언트
서버IP.port    서버IP.port    서버IP.port
ChatClient     ChatClient     ChatClient  → Thread


* 소켓은 동기적 처리 방식  - 데이터 전송시 응답 필수
* EJB는 비동기적 처리 방식 - 이메일 처리 방식 무응답